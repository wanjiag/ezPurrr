---
title: "ezPurrr example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{using-ezPurrr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ezPurrr)
library(dplyr)
library(tidyr)
library(ggplot2)
```

A nested dataset is needed to use functions.

```{r}
nest_df <- palmerpenguins::penguins %>%
  group_by(island, species) %>%
  nest()

head(nest_df)
```

# `sample_*()`


### `sample_row()`

sample_row() returns one random or one particular row (with `index` argument) from the nested data as a list or a data frame. If returning a list (default), one row of the nested data will the first item of the list, and each of the other grouping variables will be another item in the list. If returning a data frame (with `type = df` argument), then the data frame will include one row of the nested data, as well as each grouping variable as a column with identical repeated content.


```{r}

# In here, species and island are the grouping variables.

nest_df %>% sample_row()

nest_df %>% sample_row(index = 3) %>% head()

nest_df %>% sample_row(index = 3, type = 'df') %>% head()

```

### `sample_data()`

sample_data() returns one random or one particular data column (with `index` argument) from the nested data with no grouping variables.

```{r}
nest_df %>% sample_data()

nest_df %>% sample_data(index = 3)
```

### `sample_group()`

sample_group() returns one random or one particular grouping columns (with `index` argument) from the nested dataset with no data.

```{r}
nest_df %>% sample_group()

nest_df %>% sample_group(index = 3)
```

# `broadcast()`

### `broadcast()`

You can use the sampling dataset to test the code you want to be applied for each row, such as figures or `lm()` models.

Plotting:
```{r}
nest_df %>% 
  sample_data(index = 3) %>% 
  ggplot(aes(x = bill_length_mm,
                           y = bill_depth_mm,
                           color = body_mass_g)) +
  geom_point()
```

Then, by wrapping it into a function, it can be easily broadcasted into each row of the nested dataset. 

```{r}
plotting <- function(data){
  data %>% ggplot(aes(x = bill_length_mm,
                             y = bill_depth_mm,
                             color = body_mass_g)) +
    geom_point()
}

broadcasted_df = nest_df %>% broadcast(plotting)

broadcasted_df$output[[1]]

```

You can also use it for modeling or other functions:
```{r}
tmp_df = nest_df %>% 
  sample_data(index = 3)

lm(body_mass_g ~ bill_length_mm * bill_depth_mm, data = tmp_df)

modeling <- function(data){
   lm(body_mass_g ~ bill_length_mm + bill_depth_mm, data = data)
}

nest_df %>% broadcast(modeling) %>% .$output

```

Instead of a list, you can also make the output a number (double).
```{r}

modeling <- function(data){
  model = lm(body_mass_g ~ bill_length_mm + bill_depth_mm, data = data)
  model$coefficients[2] # the slope for bill_length_mm
}

nest_df %>% broadcast(modeling) %>% .$output

```

### `broadcast_group()`

`broadcast_group()` allows you to also use grouping variables in the function. It is still under develop so currently it only works in a more limited way. For example, you can include grouping variables as title for plots.


```{r}
df = nest_df %>% 
  sample_row(index = 3, type = 'list')

plotting = function(data, species, island){
  ggplot(data, aes(x = bill_length_mm,
                             y = bill_depth_mm,
                             color = body_mass_g)) +
    geom_point() +
    labs(title = paste(species, island))
}

plotting(df$data, df$species, df$island)

nest_df = nest_df %>% broadcast_group(plotting)

nest_df$output[[1]]
nest_df$output[[4]]

```

# Testing::

```{r eval=FALSE, include=FALSE}
tmp <- quo(
 data %>% 
   filter(bill_length_mm > 50) %>% 
   select(bill_length_mm, bill_depth_mm) %>% 
   cor()
 )

tmp

library(rlang)
expr <- quo_get_expr(tmp)
chr_expr <- gsub("ex_data", "data", expr)
expr <- parse_expr(paste0(parse_exprs(chr_expr[-1]), collapse = " %>% "))
 
map(nested_d, !!tmp)
```


```{r eval=FALSE, include=FALSE}
#This is just and example code chunk where Daniel was playing with the package.

library(palmerpenguins)
library(purrr)
library(dplyr)
library(ggplot2)
library(ezPurrr)

nested_d <- penguins %>% 
  nest_by(species) 

ex_data <- nested_d %>% 
  sample_data()

ggplot(ex_data, aes(sex, flipper_length_mm)) +
  geom_boxplot(aes(fill = sex)) +
  guides(fill = "none") +
  theme_minimal()

# wrap in a function
p <- function(d) {
  ggplot(d, aes(.data$sex, .data$flipper_length_mm)) +
    geom_boxplot(aes(fill = .data$sex)) +
    guides(fill = "none") +
    theme_minimal()
}

# this doesn't seem to work
#broadcast(nested_d, p)

# this does, so I would have expected the above to
map(nested_d$data, p)

# try a second one
ex_data %>% 
  filter(bill_length_mm > 50) %>% 
  select(bill_length_mm, bill_depth_mm) %>% 
  cor() 

# wrap in function
f <- function(d) {
  d %>% 
    filter(.data$bill_length_mm > 50) %>% 
    select(.data$bill_length_mm, .data$bill_depth_mm) %>% 
    cor() 
}
# broadcast(nested_d, f) # also doesn't work
map(nested_d$data, f) # this does

# Me messing about with quosures unsuccessfully 
# tmp <- quo(
#   data %>% 
#     filter(bill_length_mm > 50) %>% 
#     select(bill_length_mm, bill_depth_mm) %>% 
#     cor()
#   )
# 
# tmp
# 
# library(rlang)
# expr <- quo_get_expr(tmp)
# chr_expr <- gsub("ex_data", "data", expr)
# expr <- parse_expr(paste0(parse_exprs(chr_expr[-1]), collapse = " %>% "))
# 
# map(nested_d, !!tmp)
```
